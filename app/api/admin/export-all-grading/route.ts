import { NextRequest, NextResponse } from 'next/server';
import config from '../../../config';
import * as XLSX from 'xlsx';
import { MongoClient } from 'mongodb';

const SERVER_BASE = config.serverUrl;

// MongoDB connection URL - using the same credentials as mentor server
const DB_USERNAME = process.env.dbUserName || "sql-admin";
const DB_PASSWORD = process.env.dbPassword || "SMff5PqhhoVbX6z7";
const MONGO_URL = process.env.MONGODB_URI || `mongodb+srv://${DB_USERNAME}:${DB_PASSWORD}@sqlmentor.ydqmecv.mongodb.net/?retryWrites=true&w=majority&appName=SQLMentor`;

interface StudentAnswer {
  examId: string;
  studentEmail: string;
  studentName?: string;
  studentId?: string;
  questionIndex: number;
  studentAnswer: string;
  timeSpent: number;
  timestamp: string;
  isCorrect: boolean;
  grade?: number;
  feedback?: string;
  examStartTime: string;
  _id?: string;
}

interface Question {
  id: number;
  question: string;
  difficulty: string;
  points: number;
  solution_example?: string;
  answerCount?: number;
  gradedCount?: number;
  ungradedCount?: number;
}

interface QuestionWithAnswers extends Question {
  answers?: StudentAnswer[];
  totalAnswers?: number;
  gradedAnswers?: number;
  averageGrade?: number;
}

// Configuration for performance
const EXPORT_TIMEOUT = 50000; // 50 seconds (Vercel has 60s limit)
const BATCH_SIZE = 5; // Reduce batch size for better reliability
const ANSWERS_LIMIT = 300; // Reduce limit for faster processing
const QUESTION_TIMEOUT = 15000; // 15 seconds per question (increased from 8s)
const QUESTIONS_TIMEOUT = 15000; // 15 seconds for questions fetch

export async function GET(request: NextRequest) {
  try {
    console.log('üöÄ Starting DIRECT DATABASE export...');
    
    // Connect directly to MongoDB with increased timeout and better error handling
    const client = new MongoClient(MONGO_URL, {
      connectTimeoutMS: 60000, // 60 seconds
      serverSelectionTimeoutMS: 60000, // 60 seconds
      socketTimeoutMS: 60000, // 60 seconds for socket operations
      maxPoolSize: 1,
      retryWrites: true,
      heartbeatFrequencyMS: 30000, // 30 seconds between heartbeats
    });
    
    console.log('üîå Connecting to MongoDB...');
    await client.connect();
    console.log('‚úÖ Connected to MongoDB successfully');
    
    try {
      // Get all student data directly from database
      const result = await performDirectDatabaseExport(client);
      await client.close();
      console.log('‚úÖ Database connection closed');
      return result;
      
    } catch (error) {
      console.error('‚ùå Error in performDirectDatabaseExport:', error);
      await client.close();
      throw error;
    }
    
  } catch (error) {
    console.error('‚ùå Error in direct database export:', error);
    console.error('Error details:', {
      name: error.name,
      message: error.message,
      code: error.code
    });
    
    // Fallback to API-based export only if database fails
    console.log('üîÑ Database connection failed, falling back to mentor-server API export...');
    return await performMentorServerExport();
  }
}

async function performDirectDatabaseExport(client: any) {
  console.log('üìä Fetching data directly from "experiment" database...');
  
  try {
    // Connect to the experiment database specifically  
    const experimentDb = client.db("experiment");
    console.log('‚úÖ Connected to experiment database');
    
    // First, test basic collection access
    console.log('üîç Testing basic collection access...');
    const testCount = await experimentDb.collection("finalExams").countDocuments();
    console.log(`‚úÖ Collection accessible: ${testCount} total documents`);
    
    // Get completed final exams with graded answers (limit for testing)
    console.log('üîç Querying finalExams collection...');
    
    // Try the simplest possible query first
    console.log('‚è±Ô∏è Trying minimal query first...');
    const minimalQueryPromise = experimentDb.collection("finalExams")
      .find({})
      .limit(10)
      .maxTimeMS(15000)
      .toArray();
    
    const quickTimeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Minimal query timeout after 20 seconds')), 20000);
    });
    
    let finalExams;
    try {
      finalExams = await Promise.race([minimalQueryPromise, quickTimeoutPromise]);
      console.log(`‚úÖ Minimal query succeeded - found ${finalExams.length} exams`);
    } catch (error) {
      console.log('‚ùå Even minimal query failed, falling back to API export');
      throw new Error('Database query performance issue - using API fallback');
    }
    
    console.log(`‚úÖ Found ${finalExams.length} completed exams`);
    
    // Filter for exams that actually have grades (do this after query to avoid complex MongoDB query)
    console.log('üîç Filtering for graded exams...');
    const gradedExams = finalExams.filter((exam: any) => 
      exam.review && 
      exam.review.questionGrades && 
      Array.isArray(exam.review.questionGrades) && 
      exam.review.questionGrades.length > 0
    );
    
    console.log(`‚úÖ Found ${gradedExams.length} exams with grades`);
    
    if (gradedExams.length === 0) {
      console.log('‚ö†Ô∏è No graded exams found');
      return await createEmptyExport();
    }
    
    // Also get questions collection for additional question details
    console.log('üîç Querying questions collection...');
    const questionsPromise = experimentDb.collection("questions")
      .find({})
      .maxTimeMS(5000) // 5 second timeout
      .toArray();
      
    const questionsTimeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Questions query timeout')), 8000);
    });
    
    const questions = await Promise.race([questionsPromise, questionsTimeoutPromise]);
    console.log(`‚úÖ Found ${questions.length} questions`);
    
    // Process and organize data by student
    console.log('‚öôÔ∏è Processing exam data...');
    const allStudentData = new Map<string, any>();
    
    gradedExams.forEach((exam: any) => {
      const studentKey = exam.studentEmail || 'unknown';
      
      if (!studentKey || studentKey === 'unknown') return;
      
      if (!allStudentData.has(studentKey)) {
        allStudentData.set(studentKey, {
          studentEmail: exam.studentEmail || '◊ú◊ê ◊ñ◊û◊ô◊ü',
          studentName: exam.studentName || '◊ú◊ê ◊¶◊ï◊ô◊ü',
          studentId: exam.studentId || '◊ú◊ê ◊¶◊ï◊ô◊ü',
          examId: exam._id.toString(),
          examStartTime: exam.startTime || '',
          questions: []
        });
      }
      
      const studentData = allStudentData.get(studentKey);
      
      // Process each answer in mergedAnswers
      if (exam.mergedAnswers && Array.isArray(exam.mergedAnswers)) {
        exam.mergedAnswers.forEach((answer: any) => {
          // Find the corresponding grade from review.questionGrades
          let grade = '◊ú◊ê ◊¶◊ï◊ô◊ü';
          let feedback = '◊ê◊ô◊ü ◊û◊©◊ï◊ë';
          let maxScore = 0;
          
          if (exam.review && exam.review.questionGrades) {
            const questionGrade = exam.review.questionGrades.find((qg: any) => qg.questionIndex === answer.questionIndex);
            if (questionGrade) {
              grade = questionGrade.score ?? '◊ú◊ê ◊¶◊ï◊ô◊ü';
              feedback = questionGrade.feedback || '◊ê◊ô◊ü ◊û◊©◊ï◊ë';
              maxScore = questionGrade.maxScore || 0;
            }
          }
          
          // Find question details
          const questionId = parseInt(answer.questionId) || parseInt(answer.questionDetails?.id) || answer.questionDetails?.id;
          const questionDetails = questions.find(q => q.id === questionId);
          
          studentData.questions.push({
            questionId: questionId,
            questionText: answer.questionText || questionDetails?.question || '◊©◊ê◊ú◊î ◊ú◊ê ◊ñ◊û◊ô◊†◊î',
            questionDifficulty: answer.difficulty || questionDetails?.difficulty || '◊ú◊ê ◊¶◊ï◊ô◊ü',
            questionPoints: maxScore || questionDetails?.points || 0,
            questionIndex: answer.questionIndex ?? 0,
            studentAnswer: answer.studentAnswer || answer.answer || '◊ú◊ê ◊ñ◊û◊ô◊ü',
            timeSpent: answer.timeSpent || 0,
            isCorrect: answer.isCorrect || false,
            grade: grade,
            feedback: feedback,
            timestamp: answer.timestamp || answer.submittedAt || exam.startTime || '',
            solutionExample: questionDetails?.solution_example || '◊ê◊ô◊ü ◊ì◊ï◊í◊û◊î',
            gradedBy: exam.review?.gradedBy || 'admin',
            maxScore: maxScore
          });
        });
      }
    });
    
    console.log(`‚úÖ Organized data for ${allStudentData.size} students`);
    console.log(`üìä Total question responses: ${Array.from(allStudentData.values()).reduce((sum, student) => sum + student.questions.length, 0)}`);
    
    console.log('üìä Creating Excel export...');
    return await createExcelExport(allStudentData);
    
  } catch (error) {
    console.error('‚ùå Error in performDirectDatabaseExport:', error);
    throw error;
  }
}

async function performMentorServerExport() {
  console.log('üöÄ Using mentor-server API for export...');
  
  try {
    // Get data directly from mentor-server API which is already connected to DB
    const mentorServerUrl = process.env.MENTOR_SERVER_URL || 'https://database-mentor.vercel.app';
    
    console.log('üìã Fetching final exams from mentor-server...');
    const response = await fetch(`${mentorServerUrl}/admin/final-exams?limit=100`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
      cache: 'no-store',
      signal: AbortSignal.timeout(30000), // 30 second timeout
    });

    if (!response.ok) {
      throw new Error(`Mentor-server API failed: ${response.status}`);
    }

    const data = await response.json();
    console.log(`‚úÖ Got ${data.examSessions?.length || 0} exams from mentor-server`);
    
    // Process the data into Excel format
    const examSessions = data.examSessions || [];
    const gradedExams = examSessions.filter((exam: any) => exam.graded);
    
    console.log(`üìä Found ${gradedExams.length} graded exams`);
    
    if (gradedExams.length === 0) {
      return await createEmptyExport();
    }
    
    // Create simple Excel export from the data
    const studentData = new Map<string, any>();
    
    // For now, create a simple summary export
    gradedExams.forEach((exam: any) => {
      const studentKey = exam.studentEmail || 'unknown';
      
      if (!studentData.has(studentKey)) {
        studentData.set(studentKey, {
          studentEmail: studentKey,
          studentName: exam.studentName || '◊ú◊ê ◊ñ◊û◊ô◊ü',
          studentId: exam.studentId || '◊ú◊ê ◊ñ◊û◊ô◊ü',
          examDate: exam.startTime ? new Date(exam.startTime).toLocaleDateString('he-IL') : '◊ú◊ê ◊ñ◊û◊ô◊ü',
          totalScore: exam.score || 0,
          maxScore: exam.totalQuestions ? exam.totalQuestions * 10 : 100, // Estimate
          status: exam.status || '◊ú◊ê ◊ñ◊û◊ô◊ü',
          examId: exam._id
        });
      }
    });
    
    // Create Excel workbook
    const wb = XLSX.utils.book_new();
    
    // Student Overview Sheet
    const studentOverviewData = Array.from(studentData.values()).map(student => ({
      '◊õ◊™◊ï◊ë◊™ ◊û◊ô◊ô◊ú': student.studentEmail,
      '◊©◊ù ◊î◊™◊ú◊û◊ô◊ì': student.studentName,
      '◊û◊°◊§◊® ◊™◊ú◊û◊ô◊ì': student.studentId,
      '◊™◊ê◊®◊ô◊ö ◊î◊ë◊ó◊ô◊†◊î': student.examDate,
      '◊¶◊ô◊ï◊ü': student.totalScore,
      '◊¶◊ô◊ï◊ü ◊û◊ß◊°◊ô◊û◊ú◊ô': student.maxScore,
      '◊ê◊ó◊ï◊ñ◊ô◊ù': student.maxScore > 0 ? Math.round((student.totalScore / student.maxScore) * 100) + '%' : '0%',
      '◊°◊ò◊ò◊ï◊°': student.status,
      '◊û◊ñ◊î◊î ◊ë◊ó◊ô◊†◊î': student.examId
    }));
    
    const ws1 = XLSX.utils.json_to_sheet(studentOverviewData);
    XLSX.utils.book_append_sheet(wb, ws1, 'Student Overview');
    
    // Generate and return Excel file
    const excelBuffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
    
    const headers = new Headers({
      'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'Content-Disposition': `attachment; filename="grading_export_simple_${new Date().toISOString().split('T')[0]}.xlsx"`,
      'Content-Length': excelBuffer.length.toString(),
    });
    
    console.log(`‚úÖ Generated simple Excel export: ${studentOverviewData.length} students`);
    
    return new NextResponse(excelBuffer, { 
      status: 200, 
      headers 
    });
    
  } catch (error) {
    console.error('‚ùå Mentor-server export failed:', error);
    
    // Final fallback - create empty export
    console.log('üîÑ Creating empty export as final fallback...');
    return await createEmptyExport();
  }
}

async function performAPIExport() {
  const startTime = Date.now();
  console.log('üìã Fetching questions in optimized mode...');
  
  // Step 1: Fetch questions with smaller initial batch
  const questionsResponse = await fetch(`${SERVER_BASE}/api/admin/questions-optimized?page=1&limit=50&includeGradingStatus=true`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
      cache: 'no-store',
    signal: AbortSignal.timeout(QUESTIONS_TIMEOUT),
    });

    if (!questionsResponse.ok) {
      throw new Error('Failed to fetch questions');
    }

    const questionsData = await questionsResponse.json();
    const questions: QuestionWithAnswers[] = questionsData.questions || [];
    
    console.log(`‚úÖ Found ${questions.length} questions`);
    
  if (questions.length === 0) {
    return await createEmptyExport();
  }

  // Step 2: Process questions in batches to avoid timeout
  console.log('üë®‚Äçüéì Fetching student answers in optimized batches...');
  
  const allStudentData = new Map<string, any>();
  
  // Process questions in smaller batches
  for (let batchStart = 0; batchStart < questions.length; batchStart += BATCH_SIZE) {
    const batchEnd = Math.min(batchStart + BATCH_SIZE, questions.length);
    const batch = questions.slice(batchStart, batchEnd);
    
    console.log(`üîÑ Processing batch ${Math.floor(batchStart/BATCH_SIZE) + 1}/${Math.ceil(questions.length/BATCH_SIZE)} (questions ${batchStart + 1}-${batchEnd})`);
    
    // Process batch in parallel instead of sequential
    const batchPromises = batch.map(async (questionData, index) => {
      const questionId = questionData?.id;
      
      if (!questionId) {
        console.log(`‚ö†Ô∏è Skipping question - missing ID`);
        return null;
      }
      
      try {
        const answersResponse = await fetch(`${SERVER_BASE}/api/admin/question/${questionId}/answers-optimized?page=1&limit=${ANSWERS_LIMIT}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
          cache: 'no-store',
          signal: AbortSignal.timeout(QUESTION_TIMEOUT),
        });

        if (answersResponse.ok) {
          const answersData = await answersResponse.json();
          const answers: StudentAnswer[] = answersData.answers || [];
          
          console.log(`   üìä Found ${answers.length} answers for question ${questionId}`);
          
          return {
            questionId,
            questionData,
            answers,
            questionFromAPI: answersData.question
          };
        } else {
          console.log(`   ‚ö†Ô∏è Failed to fetch answers for question ${questionId}`);
          return null;
        }
      } catch (questionError) {
        console.log(`   ‚ùå Error fetching answers for question ${questionId}:`, questionError);
        return null;
      }
    });
    
    // Wait for all requests in this batch to complete
    const batchResults = await Promise.allSettled(batchPromises);
    
    // Count successful vs failed requests
    let successCount = 0;
    let failCount = 0;
    
    // Process successful results
    batchResults.forEach((result) => {
      if (result.status === 'fulfilled' && result.value) {
        successCount++;
        const { questionId, questionData, answers, questionFromAPI } = result.value;
        
        // Organize answers by student
          answers.forEach(answer => {
            const studentKey = answer?.studentEmail;
            
            if (!studentKey) {
              return;
            }
            
            if (!allStudentData.has(studentKey)) {
              allStudentData.set(studentKey, {
                studentEmail: answer.studentEmail || '◊ú◊ê ◊ñ◊û◊ô◊ü',
                studentName: answer.studentName || '◊ú◊ê ◊¶◊ï◊ô◊ü',
                studentId: answer.studentId || '◊ú◊ê ◊¶◊ï◊ô◊ü',
                examId: answer.examId || '◊ú◊ê ◊ñ◊û◊ô◊ü',
                examStartTime: answer.examStartTime || '',
                questions: []
              });
            }
            
            const studentData = allStudentData.get(studentKey);
            studentData.questions.push({
              questionId: questionId,
            questionText: questionFromAPI?.question || questionData?.question || '◊©◊ê◊ú◊î ◊ú◊ê ◊ñ◊û◊ô◊†◊î',
            questionDifficulty: questionFromAPI?.difficulty || questionData?.difficulty || '◊ú◊ê ◊¶◊ï◊ô◊ü',
            questionPoints: questionFromAPI?.points || questionData?.points || 0,
              questionIndex: answer.questionIndex ?? 0,
              studentAnswer: answer.studentAnswer || '◊ú◊ê ◊ñ◊û◊ô◊ü',
              timeSpent: answer.timeSpent || 0,
              isCorrect: answer.isCorrect || false,
              grade: answer.grade ?? '◊ú◊ê ◊¶◊ï◊ô◊ü',
              feedback: answer.feedback || '◊ê◊ô◊ü ◊û◊©◊ï◊ë',
              timestamp: answer.timestamp || '',
            solutionExample: questionFromAPI?.solution_example || questionData?.solution_example || '◊ê◊ô◊ü ◊ì◊ï◊í◊û◊î'
          });
          });
        } else {
        failCount++;
        if (result.status === 'rejected') {
          console.log(`   ‚ö†Ô∏è Batch request failed:`, result.reason?.message || 'Unknown error');
        }
      }
    });
    
    console.log(`   üìä Batch completed: ${successCount} success, ${failCount} failed`);
    
    // If too many failures, stop processing to avoid infinite loops
    if (failCount > successCount && failCount >= 3) {
      console.log('‚ö†Ô∏è Too many failures in batch, stopping to prevent server overload');
      break;
    }
    
    // Add small delay between batches to reduce server load
    if (batchStart + BATCH_SIZE < questions.length) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
    }
    
    // Check if we're approaching timeout
    const elapsed = Date.now() - startTime;
    if (elapsed > EXPORT_TIMEOUT * 0.75) { // 75% of timeout (more conservative)
      console.log('‚è∞ Approaching timeout, stopping batch processing');
      break;
    }
  }

  console.log(`‚úÖ Organized data for ${allStudentData.size} students`);

  // Return the Excel export
  return await createExcelExport(allStudentData);
}

async function createExcelExport(allStudentData: Map<string, any>) {
  try {
    console.log('üìä Creating Excel workbook...');
    console.log(`üìä Processing data for ${allStudentData.size} students`);
    
    const workbook = XLSX.utils.book_new();
    
    // Create grading data
    console.log('‚öôÔ∏è Creating grading data array...');
    const gradingData: any[] = [];
    
    let totalQuestions = 0;
    Array.from(allStudentData.values()).forEach(student => {
      student.questions.forEach((q: any) => {
        totalQuestions++;
        gradingData.push({
          '◊©◊ù ◊°◊ò◊ï◊ì◊†◊ò': student.studentName || '◊ú◊ê ◊¶◊ï◊ô◊ü',
          '◊ê◊ô◊û◊ô◊ô◊ú': student.studentEmail || '◊ú◊ê ◊ñ◊û◊ô◊ü',
          '◊û◊ñ◊î◊î': student.studentId || '◊ú◊ê ◊¶◊ï◊ô◊ü',
          '◊û◊ñ◊î◊î ◊©◊ê◊ú◊î': q.questionId || '',
          '◊©◊ê◊ú◊î': String(q.questionText || '◊©◊ê◊ú◊î ◊ú◊ê ◊ñ◊û◊ô◊†◊î').substring(0, 200),
          '◊™◊©◊ï◊ë◊™ ◊°◊ò◊ï◊ì◊†◊ò': String(q.studentAnswer || '◊ú◊ê ◊ñ◊û◊ô◊ü'),
          '◊¶◊ô◊ï◊ü': q.grade ?? '',
          '◊¶◊ô◊ï◊ü ◊û◊ß◊°◊ô◊û◊ú◊ô': q.maxScore ?? '',
          '◊î◊¢◊®◊ï◊™': String(q.feedback || ''),
          '◊û◊ì◊®◊í': q.gradedBy || '◊ú◊ê ◊ô◊ì◊ï◊¢',
          '◊ñ◊û◊ü ◊î◊í◊©◊î': q.timestamp || ''
        });
      });
    });
    
    console.log(`‚úÖ Created ${gradingData.length} grading entries (${totalQuestions} total questions)`);
    
    // Sort by student name
    console.log('üîÑ Sorting data by student name...');
    gradingData.sort((a, b) => (a['◊©◊ù ◊°◊ò◊ï◊ì◊†◊ò'] || '').localeCompare(b['◊©◊ù ◊°◊ò◊ï◊ì◊†◊ò'] || ''));
    
    console.log('üìÑ Creating Excel sheet...');
    const gradingSheet = XLSX.utils.json_to_sheet(gradingData);
    
  // Set column widths
    gradingSheet['!cols'] = [
      { wch: 20 }, // ◊©◊ù ◊°◊ò◊ï◊ì◊†◊ò
      { wch: 25 }, // ◊ê◊ô◊û◊ô◊ô◊ú
      { wch: 15 }, // ◊û◊ñ◊î◊î
    { wch: 12 }, // ◊û◊ñ◊î◊î ◊©◊ê◊ú◊î
    { wch: 50 }, // ◊©◊ê◊ú◊î
    { wch: 50 }, // ◊™◊©◊ï◊ë◊™ ◊°◊ò◊ï◊ì◊†◊ò
    { wch: 8 },  // ◊¶◊ô◊ï◊ü
    { wch: 8 },  // ◊¶◊ô◊ï◊ü ◊û◊ß◊°◊ô◊û◊ú◊ô
    { wch: 30 }, // ◊î◊¢◊®◊ï◊™
    { wch: 10 }, // ◊û◊ì◊®◊í
    { wch: 20 }  // ◊ñ◊û◊ü ◊î◊í◊©◊î
  ];
  
  XLSX.utils.book_append_sheet(workbook, gradingSheet, '◊¶◊ô◊ï◊†◊ô◊ù ◊û◊†◊î◊ú');

  // Create student summary
    const studentSummary: any[] = [];
    
    Array.from(allStudentData.values()).forEach(student => {
      let totalPoints = 0;
      let gradedQuestions = 0;
      let totalQuestions = student.questions.length;
      
      student.questions.forEach((q: any) => {
        if (typeof q.grade === 'number') {
          totalPoints += q.grade;
          gradedQuestions++;
        }
      });
      
      studentSummary.push({
        '◊©◊ù ◊°◊ò◊ï◊ì◊†◊ò': student.studentName || '◊ú◊ê ◊¶◊ï◊ô◊ü',
        '◊û◊ñ◊î◊î': student.studentId || '◊ú◊ê ◊¶◊ï◊ô◊ü', 
        '◊¶◊ô◊ï◊ü ◊õ◊ï◊ú◊ú': totalPoints,
        '◊©◊ê◊ú◊ï◊™ ◊û◊¶◊ï◊ô◊†◊ï◊™': `${gradedQuestions}/${totalQuestions}`,
        '◊°◊ò◊ò◊ï◊°': gradedQuestions === totalQuestions ? '◊î◊ï◊©◊ú◊ù' : `◊†◊ï◊™◊®◊ï ${totalQuestions - gradedQuestions}`
      });
    });
    
    studentSummary.sort((a, b) => (a['◊©◊ù ◊°◊ò◊ï◊ì◊†◊ò'] || '').localeCompare(b['◊©◊ù ◊°◊ò◊ï◊ì◊†◊ò'] || ''));
    
    const summarySheet = XLSX.utils.json_to_sheet(studentSummary);
    
    summarySheet['!cols'] = [
    { wch: 25 }, { wch: 15 }, { wch: 12 }, { wch: 15 }, { wch: 20 }
    ];
    
    XLSX.utils.book_append_sheet(workbook, summarySheet, '◊°◊ô◊õ◊ï◊ù ◊¶◊ô◊ï◊†◊ô◊ù');

    // Generate Excel buffer
    console.log('üì¶ Generating Excel buffer...');
    const excelBuffer = XLSX.write(workbook, { 
      type: 'buffer', 
      bookType: 'xlsx',
      compression: true 
    });

    console.log('‚úÖ Excel file generated successfully');
    console.log(`üìä Export summary: ${allStudentData.size} students, ${gradingData.length} total responses`);
    console.log(`üì¶ Buffer size: ${excelBuffer.length} bytes`);

    const fileName = `all-student-grading-${new Date().toISOString().split('T')[0]}.xlsx`;
    
    console.log(`üì§ Returning Excel file: ${fileName}`);
    return new NextResponse(excelBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${fileName}"`,
        'Cache-Control': 'no-cache',
      },
    });
    
  } catch (error) {
    console.error('‚ùå Error in createExcelExport:', error);
    throw error;
  }
}

async function createEmptyExport() {
  console.log('‚ö†Ô∏è No data found - creating empty workbook');
  
  const workbook = XLSX.utils.book_new();
  const emptySheet = XLSX.utils.json_to_sheet([{
    '◊î◊ï◊ì◊¢◊î': '◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊†◊™◊ï◊†◊ô ◊¶◊ô◊ï◊†◊ô◊ù ◊ú◊ô◊ô◊¶◊ï◊ê',
    '◊°◊ô◊ë◊î ◊ê◊§◊©◊®◊ô◊™': '◊ê◊ô◊ü ◊°◊ò◊ï◊ì◊†◊ò◊ô◊ù ◊©◊¢◊†◊ï ◊¢◊ú ◊©◊ê◊ú◊ï◊™, ◊ê◊ï ◊©◊ô◊© ◊ë◊¢◊ô◊î ◊ë◊ó◊ô◊ë◊ï◊® ◊ú◊©◊®◊™',
    '◊î◊û◊ú◊¶◊î': '◊ë◊ì◊ï◊ß ◊©◊ô◊© ◊†◊™◊ï◊†◊ô ◊¶◊ô◊ï◊†◊ô◊ù ◊ë◊û◊û◊©◊ß grade-by-question ◊ï◊†◊°◊î ◊©◊ï◊ë'
  }]);
  XLSX.utils.book_append_sheet(workbook, emptySheet, '◊î◊ï◊ì◊¢◊î');
  
  const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  return new NextResponse(excelBuffer, {
    status: 200,
    headers: {
      'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'Content-Disposition': 'attachment; filename="no-data-found.xlsx"',
      'Cache-Control': 'no-cache',
    },
  });
}

async function createSimplifiedExport() {
  console.log('üîÑ Creating simplified export after timeout...');
  
  try {
    // Try to get just a few questions quickly
    const quickResponse = await fetch(`${SERVER_BASE}/api/admin/questions-optimized?page=1&limit=3`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
      cache: 'no-store',
      signal: AbortSignal.timeout(8000), // Increased timeout for simplified export
    });

    if (!quickResponse.ok) {
      return await createEmptyExport();
    }

    const data = await quickResponse.json();
    const questions = data.questions || [];

    const workbook = XLSX.utils.book_new();
    const simplifiedData = questions.map((q: any, index: number) => ({
      '◊û◊°◊§◊® ◊©◊ê◊ú◊î': q.id || index + 1,
      '◊©◊ê◊ú◊î': String(q.question || '◊ú◊ê ◊ñ◊û◊ô◊ü').substring(0, 100),
      '◊®◊û◊™ ◊ß◊ï◊©◊ô': q.difficulty || '◊ú◊ê ◊¶◊ï◊ô◊ü',
      '◊†◊ß◊ï◊ì◊ï◊™': q.points || 0,
      '◊î◊ï◊ì◊¢◊î': '◊ô◊ô◊¶◊ï◊ê ◊û◊î◊ô◊® - ◊ú◊†◊™◊ï◊†◊ô◊ù ◊û◊ú◊ê◊ô◊ù ◊†◊°◊î ◊©◊ï◊ë ◊û◊ê◊ï◊ó◊® ◊ô◊ï◊™◊®'
    }));

    const sheet = XLSX.utils.json_to_sheet(simplifiedData);
    sheet['!cols'] = [{ wch: 15 }, { wch: 50 }, { wch: 15 }, { wch: 10 }, { wch: 40 }];
    
    XLSX.utils.book_append_sheet(workbook, sheet, '◊ô◊ô◊¶◊ï◊ê ◊û◊î◊ô◊®');

    const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
    
    return new NextResponse(excelBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': 'attachment; filename="quick-export.xlsx"',
        'Cache-Control': 'no-cache',
      },
    });
  } catch (error) {
    console.error('Error creating simplified export:', error);
    return await createEmptyExport();
  }
}